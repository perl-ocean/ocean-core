<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>

  <title>Perl Ocean</title>

  <link href="css/bootstrap.min.css" rel="stylesheet">
</head>

<body>

  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
        <a class="brand" href="#">Perl Ocean</a>
        <div class="nav-collapse">
          <ul class="nav">
            <li>
              <a href="index.html">Home</a>
            </li>
            <li>
              <a href="installation.html">Getting Started</a>
            </li>
            <li>
              <a href="protocol.html">Protocol</a>
            </li>
            <li>
              <a href="development.html">Development</a>
            </li>
            <li class="active">
              <a href="#">Cluster</a>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="subnav">
      <ul class="nav nav-tabs">
        <li class="active"><a href="#">概要</a></li>
        <li><a href="#">チュートリアル</a></li>
        <li><a href="#">データベース</a></li>
        <li><a href="#">実装</a></li>
        <li><a href="clusterconfiguration.html">コンフィギュレーション</a></li>
        <li><a href="runcluster.html">サービスの開始</a></li>
      </ul>
    </div>
  </div>


  <div class="container-fluid">
    <div class="row-fluid">
      <div class="span3">
        <div class="well sidebar-nav">
          <ul class="nav nav-list">
            <li class="nav-header">目次</li>
            <li><a href="">Hoge</a></li>
          </ul>
        </div><!--/.well -->
      </div><!--/span-->

      <div class="span9">

        <div class="row-fluid">
          <div class="span12">
            <h2>サービスのスケーリングについて</h2>
            <p>サービスは、規模が大きくなっても運用できるようにしておかなければなりません。</p>
            <p>Webの世界でも、「リバースプロキシやバランサを利用したWebサービスの分散」や「レプリケーション、Shardingなどを利用したデータベースの分散やパフォーマンスチューニング」など、数え上げればきりがない程、スケーリングに関する様々なノウハウが共有される時代になっています。</p>

            <p>ところが、それらは主にWebサービスとデータベースを中心とした、プル型のアーキテクチャに最適化されたものです。</p>

            <p>XMPPのようにクライアントが接続を維持し続けるようなタイプのサービスでは、また違った考え方が必要になります。</p>
            <p>どのような課題があり、Oceanでどのようにソリューションを提供しているのかを解説します。</p>
          </div><!--/span-->
        </div><!--/row-->

        <div class="row-fluid">
          <div class="span12">
            <h2>問題</h2>
            <h3 id="socketlimit">サーバーパフォーマンスからくる同時接続数の限界</h3>
            <p>サービスの規模が拡大し、ユーザー数が増えていくといつか必ず、1サーバーあたりの同時接続数の限界に達するでしょう。サーバーの性能次第ですが、「メモリが足りなくなり、それ以上接続をもてないケース」や、「それ以上の接続を提供すると、メッセージ送信数が非常に多くなり、スループットに問題が出るケース」などが考えられます。</p>
            <h3>プロセス/スレッドのブロック</h3>
            <p>XMPPのようなサーバーでは、同時接続数が非常に多くなるために、サーバー側は多重化IOを利用してイベントドリヴンな処理をするのが一般的です。そのようなアーキテクチャ上では重い同期処理は命取りになります。例えば、一つのコネクションが何らかのIQスタンザを送ってきたときに、その要求に答えるため、データベースに同期的にクエリを飛ばします。データベースからのレスポンスを待っている間、プロセスやスレッドをブロックしてしまい、他のユーザーコネクションからのメッセージなどがつっかえてしまい、読み込みバッファがすぐに一杯になってしまいます。</p>
            <div class="alert alert-block">
              <p>HTTPでは、起動時にいくつかのプロセスを起動するpreforkや、あるいはそれぞれのプロセス上でスレッドをいくつか生成しておき、一つのリクエストに対し、一つのプロセス、スレッドでレスポンスを返していきますが、XMPPでは、場合によっては数万を超えるコネクションを維持しなければならず、スレッドを利用してもせいぜい千単位が限界であり無理があります。</p>
            </div>
            <h3>サーバーライフサイクルとサービスコード更新頻度のミスマッチ</h3>
            <p>一般的なWebのサービスでは毎日開発が続けられ、そのコードがデプロイされています。サーバーは順番に再起動され、デプロイされたコードが反映されていく、というケースが多いのではないでしょうか。(ホットデプロイを除く)。</p>
            <p>例えば一日一回このような処理をしているとします。バグが発見されたら、緊急のコード修正を行い、再びデプロイをすることになります。そうすると一日数回の再起動が発生することになります。一般的にはこのような運用が行われますが、Webサービスのようなステートレスなサービスの場合、複数並べて順番に再起動すれば、クライアントには意識させることなくサービスのリブートが可能です。</p>
            <p>ところが、XMPPのような接続しっぱなしのサービスではそのようにはいきません。再起動するときには、ぶらさがってる全てのクライアントを一つずつ切断処理を行っていく必要があり、切断されたクライアントは再びサービスの提供を受けるために、再起動後のサーバー、あるいは別のサーバーに、接続をしなおす必要があります。</p>
            
            <p>このようなサービス形態においても、上記のように一日数回の再起動をしてもよいものでしょうか。</p>

            <p>結局のところはポリシー次第になるのですが、あまり頻繁な再起動を許可したくはないタイプのサービスであることは確かです。</p>

          </div><!--/span-->
        </div><!--/row-->

        <hr />
        <div class="row-fluid">
          <div class="span12">
            <h2>Ocean Cluster</h2>
            <p>Oceanでは、前述の課題に対するソリューションとして、下の画像のような三層構成のアーキテクチャのシステムを提供しています。具体的に説明していきましょう。</p>
            <div class="alert alert-block">
              <p>もちろん、<a href="development.html">開発ガイド</a>で説明したとおり、ハンドラやコンテキストを自由に実装できますので、開発者がこの問題に対するソリューションを、フルスクラッチで好きに実装してしまうことも可能です。</p>
            </div>
            <p>[画像が入る]</p>
            <p>三つのレイヤーを、それぞれ</p>
            <ul>
              <li><b>フロントエンドノード群</b></li> 
              <li><b>メッセージブローカー</b></li> 
              <li><b>デリバリーサービス</b></li> 
            </ul>
            <p>という名で呼んでいます。</p>

            <p><b>フロントエンドノード</b>とは、単に、<a href="development.html">開発ガイド</a>でこれまで見てきたような、Ocean XMPPサーバーの事です。<b>フロントエンドノード</b>を省略して単に<b>ノード</b>とも呼ぶことにします。</p>

            <p>前節の<a href="#socketlimit">同時接続数の限界</a>で説明した通り、一台のノードで接続数の限界が来た場合、複数台のノードを並べなければなりません。これを並べたレイヤーが、<b>フロントエンドノード群</b>と呼ばれます。</p>

            <p>さて、ノードを並べたところで、上で説明したノード間の配送問題が残ります。この問題のために、サードパーティ製の<b>メッセージキューミドルウェア</b>を利用します。</p>

          </div><!--/span-->
        </div><!--/row-->

      </div><!--/span-->
    </div><!--/row-->

    <hr />
    <footer>
      <p>&copy; Lyo Kato 2012</p>
    </footer>
  </div>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script src="js/bootstrap.min.js"></script>

</body>
</html>
